{"ast":null,"code":"// Generated by CoffeeScript 2.3.1\n// # CSV Parse Sync\n\n// Provides a synchronous alternative to the CSV parser.\n\n// Usage: `records = parse(data, [options]`\nvar StringDecoder, parse;\n({\n  StringDecoder\n} = require('string_decoder'));\nparse = require('./index');\nmodule.exports = function (data) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var decoder, err, parser, records;\n  records = options.objname ? {} : [];\n  if (data instanceof Buffer) {\n    decoder = new StringDecoder();\n    data = decoder.write(data);\n  }\n  parser = new parse.Parser(options);\n  parser.push = function (record) {\n    if (options.objname) {\n      return records[record[0]] = record[1];\n    } else {\n      return records.push(record);\n    }\n  };\n  err = parser.__write(data, false);\n  if (err) {\n    throw err;\n  }\n  if (data instanceof Buffer) {\n    err = parser.__write(data.end(), true);\n    if (err) {\n      throw err;\n    }\n  }\n  err = parser.__flush();\n  if (err) {\n    throw err;\n  }\n  return records;\n};","map":{"version":3,"names":["StringDecoder","parse","require","module","exports","data","options","arguments","length","undefined","decoder","err","parser","records","objname","Buffer","write","Parser","push","record","__write","end","__flush"],"sources":["/Users/Jared/CS4664/node_modules/csv-parse/lib/sync.js"],"sourcesContent":["// Generated by CoffeeScript 2.3.1\n// # CSV Parse Sync\n\n// Provides a synchronous alternative to the CSV parser.\n\n// Usage: `records = parse(data, [options]`\nvar StringDecoder, parse;\n\n({StringDecoder} = require('string_decoder'));\n\nparse = require('./index');\n\nmodule.exports = function(data, options = {}) {\n  var decoder, err, parser, records;\n  records = options.objname ? {} : [];\n  if (data instanceof Buffer) {\n    decoder = new StringDecoder();\n    data = decoder.write(data);\n  }\n  parser = new parse.Parser(options);\n  parser.push = function(record) {\n    if (options.objname) {\n      return records[record[0]] = record[1];\n    } else {\n      return records.push(record);\n    }\n  };\n  err = parser.__write(data, false);\n  if (err) {\n    throw err;\n  }\n  if (data instanceof Buffer) {\n    err = parser.__write(data.end(), true);\n    if (err) {\n      throw err;\n    }\n  }\n  err = parser.__flush();\n  if (err) {\n    throw err;\n  }\n  return records;\n};\n"],"mappings":"AAAA;AACA;;AAEA;;AAEA;AACA,IAAIA,aAAa,EAAEC,KAAK;AAExB,CAAC;EAACD;AAAa,CAAC,GAAGE,OAAO,CAAC,gBAAgB,CAAC;AAE5CD,KAAK,GAAGC,OAAO,CAAC,SAAS,CAAC;AAE1BC,MAAM,CAACC,OAAO,GAAG,UAASC,IAAI,EAAgB;EAAA,IAAdC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAC1C,IAAIG,OAAO,EAAEC,GAAG,EAAEC,MAAM,EAAEC,OAAO;EACjCA,OAAO,GAAGP,OAAO,CAACQ,OAAO,GAAG,CAAC,CAAC,GAAG,EAAE;EACnC,IAAIT,IAAI,YAAYU,MAAM,EAAE;IAC1BL,OAAO,GAAG,IAAIV,aAAa,EAAE;IAC7BK,IAAI,GAAGK,OAAO,CAACM,KAAK,CAACX,IAAI,CAAC;EAC5B;EACAO,MAAM,GAAG,IAAIX,KAAK,CAACgB,MAAM,CAACX,OAAO,CAAC;EAClCM,MAAM,CAACM,IAAI,GAAG,UAASC,MAAM,EAAE;IAC7B,IAAIb,OAAO,CAACQ,OAAO,EAAE;MACnB,OAAOD,OAAO,CAACM,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGA,MAAM,CAAC,CAAC,CAAC;IACvC,CAAC,MAAM;MACL,OAAON,OAAO,CAACK,IAAI,CAACC,MAAM,CAAC;IAC7B;EACF,CAAC;EACDR,GAAG,GAAGC,MAAM,CAACQ,OAAO,CAACf,IAAI,EAAE,KAAK,CAAC;EACjC,IAAIM,GAAG,EAAE;IACP,MAAMA,GAAG;EACX;EACA,IAAIN,IAAI,YAAYU,MAAM,EAAE;IAC1BJ,GAAG,GAAGC,MAAM,CAACQ,OAAO,CAACf,IAAI,CAACgB,GAAG,EAAE,EAAE,IAAI,CAAC;IACtC,IAAIV,GAAG,EAAE;MACP,MAAMA,GAAG;IACX;EACF;EACAA,GAAG,GAAGC,MAAM,CAACU,OAAO,EAAE;EACtB,IAAIX,GAAG,EAAE;IACP,MAAMA,GAAG;EACX;EACA,OAAOE,OAAO;AAChB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}